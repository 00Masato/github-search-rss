{
    "version": "https://jsonfeed.org/version/1",
    "title": "rust-lang/rfcs pr",
    "home_page_url": "https://00masato.github.io/github-search-rss/rust-rfc.json",
    "feed_url": "https://00masato.github.io/github-search-rss/rust-rfc.json",
    "description": "rust-lang/rfcs pr on GitHub",
    "items": [
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/162737?u=31a4f284889d0261a2b00e45af696e84dafb1488&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Allow declaring proc macro attributes and derive macros as unsafe, and<br>\nrequiring <code class=\"notranslate\">unsafe</code> to invoke them.</p>\n<p dir=\"auto\"><a href=\"https://github.com/joshtriplett/rfcs/blob/unsafe-derives/text/3715-unsafe-derives-and-attrs.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3715",
            "title": "Unsafe derives and attributes",
            "date_modified": "2024-10-23T08:56:10.000Z",
            "date_published": "2024-10-22T13:38:06.000Z",
            "author": {
                "name": "joshtriplett",
                "url": "https://github.com/joshtriplett"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/162737?u=31a4f284889d0261a2b00e45af696e84dafb1488&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Add a syntax and mechanism for macros to access \"fields\" of high-level fragment<br>\nspecifiers that they've matched, to let macros use the Rust parser for<br>\nrobustness and future compatibility, while still extracting pieces of the<br>\nmatched syntax.</p>\n<p dir=\"auto\">This RFC introduces the syntax <code class=\"notranslate\">${fragname.field}</code>, and a couple of fragment specifiers and their fields. The goal is to add more such fragment specifiers and fields, to allow more macros to leverage the Rust parser, but the purpose of this RFC is to introduce the concept and syntax.</p>\n<p dir=\"auto\"><a href=\"https://github.com/joshtriplett/rfcs/blob/macro-fragment-fields/text/3714-macro-fragment-fields.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3714",
            "title": "Macro fragment fields",
            "date_modified": "2024-10-22T12:35:25.000Z",
            "date_published": "2024-10-20T20:08:21.000Z",
            "author": {
                "name": "joshtriplett",
                "url": "https://github.com/joshtriplett"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/15850505?u=064c10efd2d57ae0bb9d53c6d97ea0a8e550c2a6&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h2 dir=\"auto\">Summary</h2>\n<p dir=\"auto\">Relax the requirements on struct field ordering for dynamically sized fields for <code class=\"notranslate\">repr(Rust)</code> and <code class=\"notranslate\">repr(transparent)</code>, such that <code class=\"notranslate\">?Sized</code> fields can be anywhere in the field list, as long as there is only one.</p>\n<p dir=\"auto\">Note that this RFC previously added changes to <code class=\"notranslate\">repr(C)</code>, but these have since been removed.</p>\n<p dir=\"auto\"><a href=\"https://github.com/clarfonthey/rust-rfcs/blob/relaxed-dst-field-ordering/text/0000-relaxed-dst-field-ordering.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3713",
            "title": "Relaxed DST field ordering",
            "date_modified": "2024-10-21T20:46:41.000Z",
            "date_published": "2024-10-19T01:54:52.000Z",
            "author": {
                "name": "clarfonthey",
                "url": "https://github.com/clarfonthey"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/5026283?u=5904dba48d84a78b16221f9d91cfdd86c4985e5c&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h2 dir=\"auto\">Summary</h2>\n<p dir=\"auto\">Currently, the operational semantics of the type <a href=\"https://doc.rust-lang.org/beta/alloc/boxed/struct.Box.html\" rel=\"nofollow\"><code class=\"notranslate\">alloc::boxed::Box&lt;T&gt;</code></a> is in dispute, but the compiler adds llvm <code class=\"notranslate\">noalias</code> to it. To support it, the current operational semantics models have the type use a special form of the <code class=\"notranslate\">Unique</code> (Stacked Borrows) or <code class=\"notranslate\">Active</code> (Tree Borrows) tag, which has aliasing implications, validity implications, and also presents some unique complications in the model and in improvements to the type (e.g. Custom Allocators). We propose that, for the purposes of the runtime semantics of Rust, <code class=\"notranslate\">Box</code> is treated as no more special than a user-defined smart pointer you can write today<sup><a href=\"#user-content-fn-1-8170789597aab6fb75cdd403b127789e\" id=\"user-content-fnref-1-8170789597aab6fb75cdd403b127789e\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">1</a></sup>. In particular, it is given similar behaviour on a typed copy to a raw pointer.</p>\n<p dir=\"auto\"><a href=\"https://github.com/chorman0773/rust-rfcs/blob/master/text/3712-box-yesalias.md\">Rendered</a></p>\n<section data-footnotes=\"\" class=\"footnotes\"><h2 id=\"footnote-label\" class=\"sr-only\" dir=\"auto\">Footnotes</h2>\n<ol dir=\"auto\">\n<li id=\"user-content-fn-1-8170789597aab6fb75cdd403b127789e\">\n<p dir=\"auto\">We maintain some trivial validity invariants (such as alignment and address space limits) that a user cannot define, but these invariants only depend upon the value of the <code class=\"notranslate\">Box</code> itself, rather than on memory. <a href=\"#user-content-fnref-1-8170789597aab6fb75cdd403b127789e\" data-footnote-backref=\"\" aria-label=\"Back to reference 1\" class=\"data-footnote-backref\">‚Ü©</a></p>\n</li>\n</ol>\n</section>",
            "url": "https://github.com/rust-lang/rfcs/pull/3712",
            "title": "RFC: No (opsem) Magic Boxes",
            "date_modified": "2024-10-20T13:25:09.000Z",
            "date_published": "2024-10-15T20:33:39.000Z",
            "author": {
                "name": "chorman0773",
                "url": "https://github.com/chorman0773"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/155238?u=c09aaff33aa53ea99359e53bef06aa5058ac8d15&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h1 dir=\"auto\">Summary</h1>\n<p dir=\"auto\">This RFC unblock the stabilization of async closures by committing to <code class=\"notranslate\">K $Trait</code> (where <code class=\"notranslate\">K</code> is some keyword like <code class=\"notranslate\">async</code> or <code class=\"notranslate\">const</code>) as a pattern that we will use going forward to define a \"K-variant of <code class=\"notranslate\">Trait</code>\". This commitment is made as part of committing to a larger <em>syntactic design pattern</em> called <strong>the flavor pattern</strong>. The flavor pattern is \"advisory\". It details all the parts that a \"flavor-like keyword\" should have and suggests specific syntax that should be used, but it is not itself a language feature.</p>\n<p dir=\"auto\">In the flavor pattern, each flavor is tied to a specific keyword <code class=\"notranslate\">K</code>. Flavors share the \"infectious property\": code with flavor <code class=\"notranslate\">K</code> interacts naturally with other code with flavor <code class=\"notranslate\">K</code> but only interacts in limited ways with code without the flavor <code class=\"notranslate\">K</code>. Every flavor keyword <code class=\"notranslate\">K</code> should support at least the following:</p>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">K</code>-functions using the syntax <code class=\"notranslate\">K fn $name() -&gt; $ty</code>;</li>\n<li><code class=\"notranslate\">K</code>-blocks using the syntax <code class=\"notranslate\">K { $expr }</code> (and potentially <code class=\"notranslate\">K move { $expr }</code>);</li>\n<li><code class=\"notranslate\">K</code>-traits using the syntax <code class=\"notranslate\">K $Trait</code>;\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">K</code>-flavored traits should offer at least the same methods, associated types, and other trait items as the unflavored trait (there may be additional items specific to the <code class=\"notranslate\">K</code>-flavor). Some of the items will be <code class=\"notranslate\">K</code>-flavored, but not necessarily all of them.</li>\n</ul>\n</li>\n<li><code class=\"notranslate\">K</code>-closures using the syntax <code class=\"notranslate\">K [move] |$args| $expr</code> to define a K-closure;\n<ul dir=\"auto\">\n<li>Closures implement the <code class=\"notranslate\">K Fn</code> traits.</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">Some flavors rewrite code so that it executes differently (e.g., <code class=\"notranslate\">async</code>). These are called <strong>rewrite flavors</strong>. Each such flavor should have the following:</p>\n<ul dir=\"auto\">\n<li>A syntax <code class=\"notranslate\">üè†K&lt;$ty&gt;</code> defining the <code class=\"notranslate\">K</code>-type, the type that results from a <code class=\"notranslate\">K</code>-block, <code class=\"notranslate\">K</code>-function, or <code class=\"notranslate\">K</code>-closure whose body has type <code class=\"notranslate\">$ty</code>.\n<ul dir=\"auto\">\n<li>The <code class=\"notranslate\">üè†K&lt;$ty&gt;</code> is a placeholder. We expect a future RFC to define the actual syntax. (The üè† emoji is meant to symbolize a \"bikeshed\".)c</li>\n</ul>\n</li>\n<li>A \"do\" operation that, when executed in a <code class=\"notranslate\">K</code>-block, consumes a <code class=\"notranslate\">üè†K&lt;$ty&gt;</code> and produces a <code class=\"notranslate\">$ty</code> value.</li>\n<li>The property that a <code class=\"notranslate\">K</code>-function can be transformed to a regular function with a <code class=\"notranslate\">K</code>-flavored return type and body.\n<ul dir=\"auto\">\n<li>i.e., the following are roughly equivalent (the precise translation can vary so as to e.g. preserve drop order):\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">K fn $name($args) -&gt; $ty { $expr }</code></li>\n<li><code class=\"notranslate\">fn $name($args) -&gt; üè†K&lt;$ty&gt; { K { $expr } }</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 dir=\"auto\">Binding recommendations</h2>\n<p dir=\"auto\">Existing flavor-like keywords in the language do not have all of these parts. The RFC therefore includes a limited set of binding recommendations that brings them closer to conformance:</p>\n<ul dir=\"auto\">\n<li>Commit to <code class=\"notranslate\">K $Trait</code> as the syntax for applying flavors to traits, with the <code class=\"notranslate\">async Fn</code>, <code class=\"notranslate\">async FnMut</code>, and <code class=\"notranslate\">async FnOnce</code> traits being the only current usable example.</li>\n<li>Commit to adding a TBD syntax <code class=\"notranslate\">üè†async&lt;$ty&gt;</code> that will meet the equivalences described in this RFC.</li>\n</ul>\n<h2 dir=\"auto\">Not part of this RFC</h2>\n<p dir=\"auto\">The <a href=\"#future-possibilities\">Future Possibilities</a> discusses other changes we could make to make existing and planned flavors fit the pattern better. Examples of things that this RFC does NOT specify (but which early readers thought it might):</p>\n<ul dir=\"auto\">\n<li>Any form of \"effect\" or \"flavor\" generics:\n<ul dir=\"auto\">\n<li>Flavors in this RFC are a pattern for Rust designers to keep in mind as we explore possible language features, not a first-class language feature; this RFC also does not close the door on making them a first-class feature in the future.</li>\n</ul>\n</li>\n<li>Whether or how <code class=\"notranslate\">async</code> can be used with traits beyond the <code class=\"notranslate\">Fn</code> traits:\n<ul dir=\"auto\">\n<li>For example, the RFC specifies that <strong>if</strong> we add an async flavor of the <code class=\"notranslate\">Read</code> trait, it will be referred to as <code class=\"notranslate\">async Read</code>, but the RFC does <strong>not</strong> specify whether to add such a trait nor how such a trait would be defined or what its contents would be.</li>\n</ul>\n</li>\n<li>How <code class=\"notranslate\">const Trait</code> ought to work (<a href=\"https://github.com/rust-lang/rust/issues/67792\" data-hovercard-type=\"issue\" data-hovercard-url=\"/rust-lang/rust/issues/67792/hovercard\">under active exploration</a>):\n<ul dir=\"auto\">\n<li>The RFC only specifies that the syntax for naming a <code class=\"notranslate\">const</code>-flavored trait should be <code class=\"notranslate\">const Trait</code>; it does not specify what a <code class=\"notranslate\">const</code>-flavored trait would mean or when that syntax can be used.</li>\n</ul>\n</li>\n<li>What specific syntax we should use for <code class=\"notranslate\">üè†K&lt;$ty&gt;</code>:\n<ul dir=\"auto\">\n<li>We are committed to adding this syntax at least for <code class=\"notranslate\">async</code>, but the precise syntax still needs to be pinned down. <a href=\"https://github.com/rust-lang/rfcs/pull/3628\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/rust-lang/rfcs/pull/3628/hovercard\">RFC #3628</a> contains one possibility.</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\"><a href=\"https://github.com/nikomatsakis/rfcs/blob/color-pattern/text/0000-flavor-syntactic-design-pattern.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3710",
            "title": "RFC: introduce the flavor syntactic design pattern",
            "date_modified": "2024-10-23T05:38:37.000Z",
            "date_published": "2024-10-10T16:54:12.000Z",
            "author": {
                "name": "nikomatsakis",
                "url": "https://github.com/nikomatsakis"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/116025916?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">This RFC outlines the case for promoting the Rust riscv64gc-unknown-linux-gnu target to Tier-1 (without host tools) status.</p>\n<p dir=\"auto\">Shout out to <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Hoverbear/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Hoverbear\">@Hoverbear</a>, <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/danielsilverstone-ct/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/danielsilverstone-ct\">@danielsilverstone-ct</a> for their support.</p>\n<p dir=\"auto\"><a href=\"https://github.com/robin-randhawa-sifive/rust-lang-rfcs/blob/promote-riscv64-unknown-linux-gnu-to-tier1-without-host-tools/text/0000-promote-riscv64gc-unknown-linux-gnu-to-tier1-without-host-tools.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3707",
            "title": "RFC: Promote riscv64gc-unknown-linux-gnu to Tier-1 (without host tools)",
            "date_modified": "2024-10-18T02:42:16.000Z",
            "date_published": "2024-10-03T13:31:03.000Z",
            "author": {
                "name": "robin-randhawa-sifive",
                "url": "https://github.com/robin-randhawa-sifive"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/20380519?u=88c4d0c68f360b28788a6923ba70d8b2a08ca96d&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">This RFC proposes <code class=\"notranslate\">Result::todo</code> and <code class=\"notranslate\">Option::todo</code> functions which work like <code class=\"notranslate\">.unwrap()</code> but imply that error handling should be implemented later.</p>\n<p dir=\"auto\">As an example:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// unwrap is still used for cases where you *actually* want to panic-on-err\nTcpListener::bind(&amp;addr).unwrap();\n\n// we're panicking because error handling is not implemented yet.\n// this use case is common in prototype applications.\nlet int: i32 = input.parse().todo();\nlet arg2 = std::env::args().nth(2).todo();\nlet file_content = fs::read(&quot;file.txt&quot;).todo();\"><pre class=\"notranslate\"><span class=\"pl-c\">// unwrap is still used for cases where you *actually* want to panic-on-err</span>\n<span class=\"pl-smi\">TcpListener</span><span class=\"pl-kos\">::</span><span class=\"pl-en\">bind</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">&amp;</span>addr<span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">unwrap</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// we're panicking because error handling is not implemented yet.</span>\n<span class=\"pl-c\">// this use case is common in prototype applications.</span>\n<span class=\"pl-k\">let</span> int<span class=\"pl-kos\">:</span> <span class=\"pl-smi\">i32</span> = input<span class=\"pl-kos\">.</span><span class=\"pl-en\">parse</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">todo</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> arg2 = std<span class=\"pl-kos\">::</span>env<span class=\"pl-kos\">::</span><span class=\"pl-en\">args</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">nth</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">2</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">todo</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> file_content = fs<span class=\"pl-kos\">::</span><span class=\"pl-en\">read</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"file.txt\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">todo</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">n.b. The initial version of this RFC also proposed <code class=\"notranslate\">.unreachable()</code>. Upon more thought and some feedback I've decided that <code class=\"notranslate\">.unreachable()</code> isn't ideal -- It is easily emulated with <code class=\"notranslate\">.expect(\"reason for why error cannot happen\")</code>. Attaching <code class=\"notranslate\">.unreachable()</code> onto this RFC drags it down quite a bit. I think <code class=\"notranslate\">.todo()</code> is a strong improvement to Rust, but I can't think a strong case for <code class=\"notranslate\">.unreachable()</code>.</p>\n<hr>\n<p dir=\"auto\"><a href=\"https://github.com/zkrising/rfcs/blob/semantic-unwraps/text/3706-option-result-todo.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3706",
            "title": "[RFC] Add `Option::todo` and `Result::todo`",
            "date_modified": "2024-10-21T09:10:22.000Z",
            "date_published": "2024-10-03T12:03:39.000Z",
            "author": {
                "name": "zkrising",
                "url": "https://github.com/zkrising"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/18526288?u=a851e2ec349404d3ad63a62786fe9a35009fa8d1&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">We have <code class=\"notranslate\">From</code> for infallible, <code class=\"notranslate\">TryFrom</code> for checked, and this proposes <code class=\"notranslate\">WrappingFrom</code> for modular conversions.</p>\n<p dir=\"auto\"><a href=\"https://github.com/scottmcm/rfcs/blob/wrapping-from/text/3703-wrapping-from.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3703",
            "title": "`num::WrappingFrom` trait for conversions between integers",
            "date_modified": "2024-10-10T08:41:20.000Z",
            "date_published": "2024-10-01T05:08:31.000Z",
            "author": {
                "name": "scottmcm",
                "url": "https://github.com/scottmcm"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/25405190?u=64314ab5744b9926919e515a477872955c6562ce&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Add helper methods on primitive pointer types to facilitate getting and setting the tag of a pointer.<br>\nIntended to work with programs that make use of architecture features such as AArch64<br>\nTop-Byte Ignore (TBI), the primary use-case being writing tagging memory allocators.</p>\n<p dir=\"auto\"><a href=\"https://github.com/mrkajetanp/rfcs/blob/ptr-tag-helpers/text/3700-ptr-tag-helpers.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3700",
            "title": "Add helper methods on primitive pointer types for pointer tagging",
            "date_modified": "2024-10-22T10:44:22.000Z",
            "date_published": "2024-09-26T14:49:36.000Z",
            "author": {
                "name": "mrkajetanp",
                "url": "https://github.com/mrkajetanp"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/162737?u=31a4f284889d0261a2b00e45af696e84dafb1488&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Many crates support deriving their traits with <code class=\"notranslate\">derive(Trait)</code>. Today, this<br>\nrequires defining proc macros, in a separate crate, typically with several<br>\nadditional dependencies adding substantial compilation time, and typically<br>\nguarded by a feature that users need to remember to enable.</p>\n<p dir=\"auto\">However, many common cases of derives don't require any more power than an<br>\nordinary <code class=\"notranslate\">macro_rules!</code> macro. Supporting these common cases would allow many<br>\ncrates to avoid defining proc macros, reduce dependencies and compilation time,<br>\nand provide these macros unconditionally without requiring the user to enable a<br>\nfeature.</p>\n<p dir=\"auto\">I've reviewed several existing proc-macro-based derives in the ecosystem, and<br>\nit appears that many would be able to use this feature to avoid needing proc<br>\nmacros at all.</p>\n<p dir=\"auto\"><a href=\"https://github.com/joshtriplett/rfcs/blob/declarative-derive-macros/text/3698-declarative-derive-macros.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3698",
            "title": "Declarative `macro_rules!` derive macros",
            "date_modified": "2024-10-22T13:05:27.000Z",
            "date_published": "2024-09-21T01:51:14.000Z",
            "author": {
                "name": "joshtriplett",
                "url": "https://github.com/joshtriplett"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/162737?u=31a4f284889d0261a2b00e45af696e84dafb1488&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Many crates provide attribute macros. Today, this requires defining proc<br>\nmacros, in a separate crate, typically with several additional dependencies<br>\nadding substantial compilation time, and typically guarded by a feature that<br>\nusers need to remember to enable.</p>\n<p dir=\"auto\">However, many common cases of attribute macros don't require any more power<br>\nthan an ordinary <code class=\"notranslate\">macro_rules!</code> macro. Supporting these common cases would<br>\nallow many crates to avoid defining proc macros, reduce dependencies and<br>\ncompilation time, and provide these macros unconditionally without requiring a<br>\nthe user to enable a feature.</p>\n<p dir=\"auto\">I've reviewed several existing proc-macro-based attributes in the ecosystem,<br>\nand it appears that many would be able to use this feature to avoid needing<br>\nproc macros at all.</p>\n<p dir=\"auto\"><a href=\"https://github.com/joshtriplett/rfcs/blob/declarative-attribute-macros.md/text/3697-declarative-attribute-macros.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3697",
            "title": "Declarative `macro_rules!` attribute macros",
            "date_modified": "2024-10-22T12:53:58.000Z",
            "date_published": "2024-09-21T01:15:27.000Z",
            "author": {
                "name": "joshtriplett",
                "url": "https://github.com/joshtriplett"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/3757567?u=da6a6ffd479943d5ba42f5652320c26aa649ca18&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">As discussed <a href=\"https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/--print.20std-support\" rel=\"nofollow\">on Zulip</a>, this RFC proposes adding a new argument for <code class=\"notranslate\">rustc --print</code> that acts as the single source of truth for whether a target supports std.</p>\n<p dir=\"auto\"><a href=\"https://github.com/adamgemmell/rfcs/blob/dev/adagem01/std-supported/text/3693-print-std-support.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3693",
            "title": "Expose std support via --print",
            "date_modified": "2024-10-22T18:50:41.000Z",
            "date_published": "2024-09-12T15:59:32.000Z",
            "author": {
                "name": "adamgemmell",
                "url": "https://github.com/adamgemmell"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/60961?u=967a9ccc3f7dba0d5d3acd694e3cf81893defe96&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">This adds <code class=\"notranslate\">resolver.feature-unification</code> to <code class=\"notranslate\">.cargo/config.toml</code> to allow workspace unfication (cargo-workspace-hack) or per-package unification (<code class=\"notranslate\">cargo hack</code>).</p>\n<p dir=\"auto\"><a href=\"https://github.com/epage/rfcs/blob/feature-unification/text/3692-feature-unification.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3692",
            "title": "RFC: Give users control over feature unification",
            "date_modified": "2024-10-05T10:34:19.000Z",
            "date_published": "2024-09-11T22:22:19.000Z",
            "author": {
                "name": "epage",
                "url": "https://github.com/epage"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/20070360?u=c5051b99b45e27910ed27f9b2145cd90e8c3d717&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">/cc @rust-lang/crates-io</p>\n<p dir=\"auto\">A big thank you to <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/woodruffw/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/woodruffw\">@woodruffw</a> for co-authoring, providing prior art through PyPi's implementation, and all of the expert advice. üôè</p>\n<p dir=\"auto\"><a href=\"https://github.com/mdtro/rfcs/blob/mdtro/trusted-publishing-cratesio/text/3691-trusted-publishing-cratesio.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3691",
            "title": "Trusted Publishing Support on Crates.io",
            "date_modified": "2024-10-22T14:12:00.000Z",
            "date_published": "2024-09-10T17:35:19.000Z",
            "author": {
                "name": "mdtro",
                "url": "https://github.com/mdtro"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/15850505?u=064c10efd2d57ae0bb9d53c6d97ea0a8e550c2a6&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><h2 dir=\"auto\">Summary</h2>\n<p dir=\"auto\">Adds the builtin types <code class=\"notranslate\">u&lt;N&gt;</code> and <code class=\"notranslate\">i&lt;N&gt;</code>, allowing integers with an arbitrary size in bits.</p>\n<p dir=\"auto\"><a href=\"https://github.com/clarfonthey/rust-rfcs/blob/generic-integers-v2/text/0000-generic-integers.md\">Rendered</a></p>\n<h2 dir=\"auto\">Details</h2>\n<p dir=\"auto\">This is a follow-up to <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"374716653\" data-permission-text=\"Title is private\" data-url=\"https://github.com/rust-lang/rfcs/issues/2581\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/rust-lang/rfcs/pull/2581/hovercard\" href=\"https://github.com/rust-lang/rfcs/pull/2581\">#2581</a>, which was previously postponed. A lot has happened since then, and there has been general support for this change from a lot of different people. It's time.</p>\n<p dir=\"auto\">There are a few key differences from the previous RFC, but I trust that you can read.</p>\n<h2 dir=\"auto\">Thanks</h2>\n<p dir=\"auto\">Thank you to everyone who responded to the <a href=\"https://internals.rust-lang.org/t/pre-rfc-generic-integers-v2/21326\" rel=\"nofollow\">pre-RFC</a> on Internals with feedback.</p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3686",
            "title": "Generic Integers V2: It's Time",
            "date_modified": "2024-10-11T15:38:42.000Z",
            "date_published": "2024-09-01T19:36:15.000Z",
            "author": {
                "name": "clarfonthey",
                "url": "https://github.com/clarfonthey"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/1606434?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Support the following:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"#[derive(Default)]\nenum Foo {\n    #[default]\n    Bar {\n        x: Option&lt;i32&gt;,\n        y: Option&lt;i32&gt;,\n    },\n    Baz,\n}\"><pre class=\"notranslate\"><span class=\"pl-c1\">#<span class=\"pl-kos\">[</span>derive<span class=\"pl-kos\">(</span><span class=\"pl-v\">Default</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">]</span></span>\n<span class=\"pl-k\">enum</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">#<span class=\"pl-kos\">[</span>default<span class=\"pl-kos\">]</span></span>\n    <span class=\"pl-v\">Bar</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-c1\">x</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">Option</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">i32</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">,</span>\n        <span class=\"pl-c1\">y</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">Option</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">i32</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-v\">Baz</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><a href=\"https://github.com/estebank/rfcs/blob/derive-default-enum-with-fields/text/0000-derive-default-enum-with-fields.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3683",
            "title": "`#[derive(Default)]` on enum variants with fields",
            "date_modified": "2024-10-03T10:07:04.000Z",
            "date_published": "2024-08-25T18:59:16.000Z",
            "author": {
                "name": "estebank",
                "url": "https://github.com/estebank"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/1606434?v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Allow <code class=\"notranslate\">struct</code> definitions to provide default values for individual fields and<br>\nthereby allowing those to be omitted from initializers. When deriving <code class=\"notranslate\">Default</code>,<br>\nthe provided values will then be used. For example:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"#[derive(Default)]\nstruct Pet {\n    name: Option&lt;String&gt;, // impl Default for Pet will use Default::default() for name\n    age: i128 = 42, // impl Default for Pet will use the literal 42 for age\n}\"><pre class=\"notranslate\"><span class=\"pl-c1\">#<span class=\"pl-kos\">[</span>derive<span class=\"pl-kos\">(</span><span class=\"pl-v\">Default</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">]</span></span>\n<span class=\"pl-k\">struct</span> <span class=\"pl-smi\">Pet</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">name</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">Option</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">String</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">,</span> <span class=\"pl-c\">// impl Default for Pet will use Default::default() for name</span>\n    <span class=\"pl-c1\">age</span><span class=\"pl-kos\">:</span> <span class=\"pl-smi\">i128</span> = <span class=\"pl-c1\">42</span><span class=\"pl-kos\">,</span> <span class=\"pl-c\">// impl Default for Pet will use the literal 42 for age</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\"><a href=\"https://github.com/estebank/rfcs/blob/default-fields/text/0000-default-field-values.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3681",
            "title": "[RFC] Default field values",
            "date_modified": "2024-10-22T23:02:34.000Z",
            "date_published": "2024-08-22T23:46:12.000Z",
            "author": {
                "name": "estebank",
                "url": "https://github.com/estebank"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/162737?u=31a4f284889d0261a2b00e45af696e84dafb1488&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Provide a feature to simplify performing lightweight clones (such as of<br>\n<code class=\"notranslate\">Arc</code>/<code class=\"notranslate\">Rc</code>), particularly cloning them into closures or async blocks, while<br>\nstill keeping such cloning visible and explicit.</p>\n<p dir=\"auto\">A very common source of friction in asynchronous or multithreaded Rust<br>\nprogramming is having to clone various <code class=\"notranslate\">Arc&lt;T&gt;</code> reference-counted objects into<br>\nan async block or task. This is particularly common when spawning a closure as<br>\na thread, or spawning an async block as a task. Common patterns for doing so<br>\ninclude:</p>\n<div class=\"highlight highlight-source-rust notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// Use new names throughout the block\nlet new_x = x.clone();\nlet new_y = y.clone();\nspawn(async move {\n    func1(new_x).await;\n    func2(new_y).await;\n});\n\n// Introduce a scope to perform the clones in\n{\n    let x = x.clone();\n    let y = y.clone();\n    spawn(async move {\n        func1(x).await;\n        func2(y).await;\n    });\n}\n\n// Introduce a scope to perform the clones in, inside the call\nspawn({\n    let x = x.clone();\n    let y = y.clone();\n    async move {\n        func1(x).await;\n        func2(y).await;\n    }\n});\"><pre class=\"notranslate\"><span class=\"pl-c\">// Use new names throughout the block</span>\n<span class=\"pl-k\">let</span> new_x = x<span class=\"pl-kos\">.</span><span class=\"pl-en\">clone</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> new_y = y<span class=\"pl-kos\">.</span><span class=\"pl-en\">clone</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">spawn</span><span class=\"pl-kos\">(</span><span class=\"pl-k\">async</span> <span class=\"pl-k\">move</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-en\">func1</span><span class=\"pl-kos\">(</span>new_x<span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-k\">await</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-en\">func2</span><span class=\"pl-kos\">(</span>new_y<span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-k\">await</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// Introduce a scope to perform the clones in</span>\n<span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">let</span> x = x<span class=\"pl-kos\">.</span><span class=\"pl-en\">clone</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">let</span> y = y<span class=\"pl-kos\">.</span><span class=\"pl-en\">clone</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-en\">spawn</span><span class=\"pl-kos\">(</span><span class=\"pl-k\">async</span> <span class=\"pl-k\">move</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-en\">func1</span><span class=\"pl-kos\">(</span>x<span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-k\">await</span><span class=\"pl-kos\">;</span>\n        <span class=\"pl-en\">func2</span><span class=\"pl-kos\">(</span>y<span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-k\">await</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-c\">// Introduce a scope to perform the clones in, inside the call</span>\n<span class=\"pl-en\">spawn</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">let</span> x = x<span class=\"pl-kos\">.</span><span class=\"pl-en\">clone</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">let</span> y = y<span class=\"pl-kos\">.</span><span class=\"pl-en\">clone</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">async</span> <span class=\"pl-k\">move</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-en\">func1</span><span class=\"pl-kos\">(</span>x<span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-k\">await</span><span class=\"pl-kos\">;</span>\n        <span class=\"pl-en\">func2</span><span class=\"pl-kos\">(</span>y<span class=\"pl-kos\">)</span><span class=\"pl-kos\">.</span><span class=\"pl-k\">await</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">All of these patterns introduce noise every time the program wants to spawn a<br>\nthread or task, or otherwise clone an object into a closure or async block.<br>\nFeedback on Rust regularly brings up this friction, seeking a simpler solution.</p>\n<p dir=\"auto\">This RFC proposes solutions to <em>minimize</em> the syntactic weight of<br>\nlightweight-cloning objects, particularly cloning objects into a closure or<br>\nasync block, <strong>while still keeping an indication of this operation</strong>.</p>\n<hr>\n<p dir=\"auto\">This RFC is part of the \"Ergonomic ref-counting\" project goal, owned by<br>\n<a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/jkelleyrtp/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jkelleyrtp\">@jkelleyrtp</a>. Thanks to <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/jkelleyrtp/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jkelleyrtp\">@jkelleyrtp</a> and <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/nikomatsakis/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/nikomatsakis\">@nikomatsakis</a> for reviewing. Thanks to<br>\n<a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/nikomatsakis/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/nikomatsakis\">@nikomatsakis</a> for key insights in this RFC, including the idea to use <code class=\"notranslate\">use</code>.</p>\n<p dir=\"auto\"><a href=\"https://github.com/joshtriplett/rfcs/blob/use/text/3680-use.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3680",
            "title": "Simplify lightweight clones, including into closures and async blocks",
            "date_modified": "2024-09-28T08:26:04.000Z",
            "date_published": "2024-08-20T20:34:07.000Z",
            "author": {
                "name": "joshtriplett",
                "url": "https://github.com/joshtriplett"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/162737?u=31a4f284889d0261a2b00e45af696e84dafb1488&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\">Support restricting implementation of individual methods within traits, using the already reserved <code class=\"notranslate\">final</code> keyword.</p>\n<p dir=\"auto\">This makes it possible to define a trait that any crate can implement, but disallow overriding one of the trait's methods or associated functions.</p>\n<p dir=\"auto\">This was inspired in the course of writing another RFC defining a trait, which wanted precisely this feature of restricting overrides of the trait's method. I separated out this feature as its own RFC, since it's independently useful for various other purposes, and since it should be available to any crate and not just the standard library.</p>\n<p dir=\"auto\"><a href=\"https://github.com/joshtriplett/rfcs/blob/final/text/3678-final.md\">Rendered</a></p>\n<p dir=\"auto\">Tracking:</p>\n<ul dir=\"auto\">\n<li><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"2562890879\" data-permission-text=\"Title is private\" data-url=\"https://github.com/rust-lang/rust/issues/131179\" data-hovercard-type=\"issue\" data-hovercard-url=\"/rust-lang/rust/issues/131179/hovercard\" href=\"https://github.com/rust-lang/rust/issues/131179\">rust-lang/rust#131179</a></li>\n</ul>",
            "url": "https://github.com/rust-lang/rfcs/pull/3678",
            "title": "Trait method impl restrictions",
            "date_modified": "2024-10-10T17:37:46.000Z",
            "date_published": "2024-08-13T19:51:41.000Z",
            "author": {
                "name": "joshtriplett",
                "url": "https://github.com/joshtriplett"
            }
        },
        {
            "content_html": "<img src=\"https://avatars.githubusercontent.com/u/141300?u=e222ed60f0855d57158dd20d3613f4db42b4236f&v=4\" width=\"64\" height=\"64\" alt=\"\"/><br/><p dir=\"auto\"><a href=\"https://github.com/Turbo87/rust-rfcs/blob/crates-io-remove-dev-deps/text/3674-crates-io-remove-dev-deps.md\">Rendered</a></p>",
            "url": "https://github.com/rust-lang/rfcs/pull/3674",
            "title": "crates.io: Remove dev-dependencies from the index",
            "date_modified": "2024-09-01T16:09:20.000Z",
            "date_published": "2024-07-31T12:11:20.000Z",
            "author": {
                "name": "Turbo87",
                "url": "https://github.com/Turbo87"
            }
        }
    ]
}